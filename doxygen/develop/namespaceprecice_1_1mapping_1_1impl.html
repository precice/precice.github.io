<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>preCICE: precice::mapping::impl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="additional.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">preCICE<span id="projectnumber">&#160;ac22cbf</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespaceprecice.html">precice</a></li><li class="navelem"><a href="namespaceprecice_1_1mapping.html">mapping</a></li><li class="navelem"><a href="namespaceprecice_1_1mapping_1_1impl.html">impl</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">precice::mapping::impl Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:LucyKernelFunction" id="r_LucyKernelFunction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprecice_1_1mapping_1_1impl_1_1LucyKernelFunction.html">LucyKernelFunction</a></td></tr>
<tr class="memitem:MappingDataCache" id="r_MappingDataCache"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprecice_1_1mapping_1_1impl_1_1MappingDataCache.html">MappingDataCache</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af1141e1c5a9465ef6723e6fa450414ae" id="r_af1141e1c5a9465ef6723e6fa450414ae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1141e1c5a9465ef6723e6fa450414ae">Vertices</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="el" href="classprecice_1_1mesh_1_1Vertex.html">mesh::Vertex</a>&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7ccf242183b04a7f69c3bd8cd2d5f5eb" id="r_a7ccf242183b04a7f69c3bd8cd2d5f5eb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ccf242183b04a7f69c3bd8cd2d5f5eb">estimateClusterRadius</a> (unsigned int verticesPerCluster, <a class="el" href="namespaceprecice_1_1mesh.html#a51755e8d0b6a09b6e12a265c0425f890">mesh::PtrMesh</a> inMesh, const <a class="el" href="classprecice_1_1mesh_1_1BoundingBox.html">mesh::BoundingBox</a> &amp;bb)</td></tr>
<tr class="memdesc:a7ccf242183b04a7f69c3bd8cd2d5f5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an estimate for the cluster radius, which results in approximately <code class="param">verticesPerCluster</code> vertices inside of each cluster. The algorithm generates random samples in the domain and queries the <code class="param">verticesPerCluster</code> nearest-neighbors from the mesh index tree. The cluster radius is then estimated through the distance between the center vertex (random sample) and the vertex the furthest away from the center (being on the edge of the cluster).  <br /></td></tr>
<tr class="memitem:a49b7c758d52bc8132a95d9db4e8a6286" id="r_a49b7c758d52bc8132a95d9db4e8a6286"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; double, <a class="el" href="#af1141e1c5a9465ef6723e6fa450414ae">Vertices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49b7c758d52bc8132a95d9db4e8a6286">createClustering</a> (<a class="el" href="namespaceprecice_1_1mesh.html#a51755e8d0b6a09b6e12a265c0425f890">mesh::PtrMesh</a> inMesh, <a class="el" href="namespaceprecice_1_1mesh.html#a51755e8d0b6a09b6e12a265c0425f890">mesh::PtrMesh</a> outMesh, double relativeOverlap, unsigned int verticesPerCluster, bool projectClustersToInput)</td></tr>
<tr class="memdesc:a49b7c758d52bc8132a95d9db4e8a6286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clustering as a collection of <a class="el" href="#af1141e1c5a9465ef6723e6fa450414ae">Vertices</a> (representing the cluster centers) and a cluster radius, as required for the partition of unity mapping. The algorithm estimates a cluster radius based on the input parameter <code class="param">verticesPerCluster</code> (see also <a class="el" href="#a7ccf242183b04a7f69c3bd8cd2d5f5eb">estimateClusterRadius</a> above, which is directly used by the function). Afterwards, the algorithm creates a cartesian-like grid of center vertices, where the distance of the centers is defined through the <code class="param">relativeOverlap</code> and the cluster radius. The parameter <code class="param">projectClustersToInput</code> moves the cartesian center vertices to the closest vertex from the input mesh, which is useful in case of very irregular meshes or shell-shaped meshes. The algorithm also removes potentially empty cluster, i.e., clusters which would have either no vertex from the <code class="param">inMesh</code> or from the <code class="param">outMesh</code> . See also tagEmptyClusters.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="af1141e1c5a9465ef6723e6fa450414ae" name="af1141e1c5a9465ef6723e6fa450414ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1141e1c5a9465ef6723e6fa450414ae">&#9670;&#160;</a></span>Vertices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af1141e1c5a9465ef6723e6fa450414ae">precice::mapping::impl::Vertices</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="el" href="classprecice_1_1mesh_1_1Vertex.html">mesh::Vertex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CreateClustering_8hpp_source.html#l00016">16</a> of file <a class="el" href="CreateClustering_8hpp_source.html">CreateClustering.hpp</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a49b7c758d52bc8132a95d9db4e8a6286" name="a49b7c758d52bc8132a95d9db4e8a6286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b7c758d52bc8132a95d9db4e8a6286">&#9670;&#160;</a></span>createClustering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; double, <a class="el" href="#af1141e1c5a9465ef6723e6fa450414ae">Vertices</a> &gt; precice::mapping::impl::createClustering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceprecice_1_1mesh.html#a51755e8d0b6a09b6e12a265c0425f890">mesh::PtrMesh</a></td>          <td class="paramname"><span class="paramname"><em>inMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceprecice_1_1mesh.html#a51755e8d0b6a09b6e12a265c0425f890">mesh::PtrMesh</a></td>          <td class="paramname"><span class="paramname"><em>outMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>relativeOverlap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>verticesPerCluster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>projectClustersToInput</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clustering as a collection of <a class="el" href="#af1141e1c5a9465ef6723e6fa450414ae">Vertices</a> (representing the cluster centers) and a cluster radius, as required for the partition of unity mapping. The algorithm estimates a cluster radius based on the input parameter <code class="param">verticesPerCluster</code> (see also <a class="el" href="#a7ccf242183b04a7f69c3bd8cd2d5f5eb">estimateClusterRadius</a> above, which is directly used by the function). Afterwards, the algorithm creates a cartesian-like grid of center vertices, where the distance of the centers is defined through the <code class="param">relativeOverlap</code> and the cluster radius. The parameter <code class="param">projectClustersToInput</code> moves the cartesian center vertices to the closest vertex from the input mesh, which is useful in case of very irregular meshes or shell-shaped meshes. The algorithm also removes potentially empty cluster, i.e., clusters which would have either no vertex from the <code class="param">inMesh</code> or from the <code class="param">outMesh</code> . See also tagEmptyClusters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inMesh</td><td>The input mesh (input mesh for consistent, output mesh for conservative mappings), on which the clustering is computed. The input parameters <code class="param">verticesPerCluster</code> and <code class="param">projectClustersToInput</code> refer to the <code class="param">inMesh</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outMesh</td><td>The output mesh (output mesh for consistent, input mesh for conservative mappings), </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relativeOverlap</td><td>Value between zero and one, which steers the relative distance between cluster centers. A value of zero leads to no overlap, a value of one would lead to a complete overlap between clusters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verticesPerCluster</td><td>Target number of vertices per partition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projectClustersToInput</td><td>if enabled, moves the cluster centers to the closest vertex of the <code class="param">inMesh</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple for the cluster radius and a vector of vertices marking the cluster centers </dd></dl>

<p class="definition">Definition at line <a class="el" href="CreateClustering_8hpp_source.html#l00302">302</a> of file <a class="el" href="CreateClustering_8hpp_source.html">CreateClustering.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceprecice_1_1mapping_1_1impl_a49b7c758d52bc8132a95d9db4e8a6286_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a7ccf242183b04a7f69c3bd8cd2d5f5eb" name="a7ccf242183b04a7f69c3bd8cd2d5f5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccf242183b04a7f69c3bd8cd2d5f5eb">&#9670;&#160;</a></span>estimateClusterRadius()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double precice::mapping::impl::estimateClusterRadius </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>verticesPerCluster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceprecice_1_1mesh.html#a51755e8d0b6a09b6e12a265c0425f890">mesh::PtrMesh</a></td>          <td class="paramname"><span class="paramname"><em>inMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprecice_1_1mesh_1_1BoundingBox.html">mesh::BoundingBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bb</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an estimate for the cluster radius, which results in approximately <code class="param">verticesPerCluster</code> vertices inside of each cluster. The algorithm generates random samples in the domain and queries the <code class="param">verticesPerCluster</code> nearest-neighbors from the mesh index tree. The cluster radius is then estimated through the distance between the center vertex (random sample) and the vertex the furthest away from the center (being on the edge of the cluster). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">verticesPerCluster</td><td>target number of vertices in each cluster. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inMesh</td><td>mesh we want to create the clustering on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bb</td><td>bounding box of the domain. Used to place the random samples in the domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimate for the cluster radius. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CreateClustering_8hpp_source.html#l00223">223</a> of file <a class="el" href="CreateClustering_8hpp_source.html">CreateClustering.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceprecice_1_1mapping_1_1impl_a7ccf242183b04a7f69c3bd8cd2d5f5eb_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
</div><!-- contents -->

